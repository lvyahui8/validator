package org.lyh.validator;

import org.lyh.validator.BaseEntity;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.text.MessageFormat;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by lvyahui on 2015-06-27.
 *
 */
public class Validator {

    /**
     * 验证失败的错误信息，形式如下
     * {"username":{"required":"用户名必须为空",...},...}
     */
    protected Map<String,Map<String,String>> errors
        = new HashMap<String,Map<String,String>>();

    /**
     * 被校验的实体
     */
    private BaseEntity baseEntity;

    /**
     * 被校验实体的所有字段
     */
    private Field properties [] = null;

    /**
     * 被校验实体的类型
     */
    private Class clazz = null;

    /**
     * 当前正在被校验的字段
     */
    private String prop;

    /**
     * 当前执行的校验
     */
    private String validateType ;

    public Validator(BaseEntity baseEntity) {
        this.baseEntity = baseEntity;
        this.clazz = baseEntity.getClass();
        this.properties = this.clazz.getDeclaredFields();
    }



    public void setProp(String prop) {
        this.prop = prop;
    }

    public Map<String,Map<String,String>> getErrors() {
        return errors;
    }

    public Map<String,String> getError(String prop){
        return this.errors.get(prop);
    }

    public void addError(String prop,String validatorType,String message){
        Map<String,String> error = this.errors.get(prop);
        if(error==null || error.size() == 0){
            error = new HashMap<String,String>();
            errors.put(prop,error);
        }
        error.put(validatorType,message);
    }


    public boolean required(){
        Field field = this.findField();
        if(field!=null){
            field.setAccessible(true);
            try {
                Object value = field.get(baseEntity);
                //System.out.println(value);
                if(
                    value!=null
                    && !(value.getClass() == String.class && "".equals(((String)value).trim()) )
                    ){
                    //System.out.println(prop+":非空");
                    return true;
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        String name = this.baseEntity.labels.containsKey(prop)
            ? this.baseEntity.labels.get(prop) : prop;
        String message = MessageFormat.format(Messages.valueOf(validateType).getMsg(),name);
        this.addError(prop,validateType,message);
        return false;
    }

    public boolean number(){
        return false;
    }

    public boolean email(){
        return false;
    }

    public boolean url(){
        return false;
    }

    public boolean regex(){
        return false;
    }

    public boolean equals(){
        return false;
    }
    public boolean timestamp(){
        return false;
    }
    public boolean length(){
        return false;
    }
    public boolean integer(){
        return false;
    }

    private Field findField(){
        Field field = null;
        try {
            field = this.clazz.getDeclaredField(prop);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        return field;
    }

    public boolean validate(){
        String [][] rules = baseEntity.rules();
        if(rules==null){
            return true;
        }
        Class clazz = baseEntity.getClass();
        Field properties [] = clazz.getDeclaredFields();



        for (int i = 0; i < rules.length; i++) {
            String [] rule = rules[i];
            String fields[] = rule[0].split(",");
            Method validateMethod = null;
            String validateType = rule[1];
            try {
                Class<?> parameterTypes [] = null;
                // 取附加参数
                switch (validateType){
                    case "required":
                        break;
                    case "number":
                        break;
                    case "email":
                        break;
                    case "url":
                        break;
                    case "regex":
                        break;
                    case "equals":
                        break;
                    case "timestamp":
                        break;
                }

                validateMethod = this.getClass()
                    .getMethod(validateType);

                for (int j = 0; j < fields.length; j++) {
                    Object args[] = {fields[j]};
                    this.setProp(fields[j]);
                    validateMethod.invoke(this);

                    // Object ... args
                    // Object [] args
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return true;
    }

}
